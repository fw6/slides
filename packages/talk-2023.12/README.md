# Git 基础

## 什么是版本控制

版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。

有了它，就能将特定文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。
使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，也照样可以轻松恢复到原先的样子。

版本控制系统分为：
1. 本地版本控制系统：复制整个项目目录来保存不同版本，或许还会改名+备份时间以示区别。好处是简单，缺点是容易犯错。比较流行的一种方式是[RCS](https://www.gnu.org/software/rcs/)，工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化），通过应用所有的补丁，可以重新计算出各个版本的文件内容。
2. 集中化的版本控制系统(CVCS，centralized version control systems)：这类系统，诸如CVS、Subversion以及Perforce等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。缺点是中央服务器的单点故障，如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。如果中央数据库所在的磁盘发生损坏，或者数据库备份没做好，就会导致丢失所有数据。
3. 分布式版本控制系统（DVCS，distributed version control system）：这类系统，诸如Git、Mercurial、Bazaar以及Darcs等，客户端不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。

## Git 是什么

Git和其他版本控制系统最主要差别在于Git对待数据的方式。

其他大部分系统以文件变更列表的方式存储信息，这类系统**将他们存储的信息看作一组基本文件和每个文件随时间逐步累积的差异**。他们通常被称作基于差异（delta-based）或增量（incremental）的版本控制系统。
> 缺个图

Git不按照以上方式对待或保存数据。反之，Git更像是把数据看作是对小型文件系统的一组快照。
在Git中，每当你提交更新或保存项目状态时，**它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引**。
为了高效，如果文件没有修改，Git不会再次保存该文件，只保留一个链接指向之前存储的文件。Git对待数据更像是一个**[快照](https://zh.wikipedia.org/wiki/%E5%BF%AB%E7%85%A7_(%E9%9B%BB%E8%85%A6%E5%84%B2%E5%AD%98))流**。
> 缺个图


Git更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不是一个简单的VCS。

1. 几乎所有操作都是本地执行。如：浏览项目历史、提交更新、查看分支等等。意味着离线情况下几乎可以进行任何操作。
2. Git保证完整性。Git中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。
   > Git用于计算校验和的机制叫做SHA-1散列（hash，哈希）。这是一个由40个十六进制字符（0-9和a-f）组成的字符串，基于Git中文件的内容或目录结构计算出来。实际上，Git数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。
3. Git一般只添加数据。几乎所有操作都是添加数据。你执行的大部分操作，只需向数据库中填入数据，而很少会做任何不可逆的操作，如删除数据。

## Git 的三种状态

Git有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。
- 已修改表示修改了文件，但还没保存到数据库中。
- 已暂存表示对已修改文件的当前版本做了标记，使之包含在下次提交的快照中。
- 已提交表示数据已经安全地保存在本地数据库中。
> 缺个图。展示三种状态之间的关系

- 工作区是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。
- 暂存区是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。Git术语称作‘索引’，不过一般说法还是叫暂存区。
- Git仓库是Git用来保存项目的元数据和对象数据库的地方。这是Git最重要的部分，从其他计算机克隆仓库时，拷贝的就是这里的数据。

如果Git目录中保存着特定版本的文件，就属于*已提交*状态。如果文件已修改并放入了暂存区，就属于*已暂存*状态。如果自上次取出后，作了修改但还没有放到暂存区域，就是*已修改*状态。

## Git配置

Git自带一个git config的工具来帮助设置控制Git外观和行为的配置变量。这些变量存放在三个不同的位置：
1. /etc/gitconfig文件：包含系统上每一个用户及他们仓库的通用配置。如果使用带有--system选项的git config时，它会从此文件读写配置变量。
2. ~/.gitconfig文件：只针对当前用户。可以传递--global选项让Git读写此文件。
3. 当前使用仓库的Git目录中的config文件（就是.git/config）：针对该仓库。

每一个级别覆盖上一级别的配置，所以.git/config里的配置变量会覆盖/etc/gitconfig中的配置变量。

可以使用如下命令查看所有的配置以及它们所在的文件：
```shell
$ git config --list --show-origin
```

初次使用Git时要做的第一件事就是设置你的名字和邮箱地址。每次Git提交时都会引用这两条信息，如下：
```shell
$ git config --global user.name feng.w
$ git config --global user.email feng.w@trip.com
```

如果要检查你的配置，可以使用git config --list命令来列出所有Git当时能找到的配置。
```shell
$ git config --list
credential.helper=osxkeychain
init.defaultbranch=main
user.email=feng.w@trip.com
user.name=feng.w
```

可以查询某个特定配置项的原始值，它会告诉你哪个配置文件最后设置了该值：
```shell
$ git config --show-origin user.name
file:/Users/fengwei/.gitconfig-work     feng.w
```

## 仓库初始化

执行`git init`，将创建一个名为`.git`的子目录，这个子目录含有初始化的Git仓库中所有的必须文件，这些文件是Git仓库的骨干。此时项目中文件还未被跟踪


## 文件状态

检查文件状态：
```shell
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean
```

这说明当前的工作目录相当干净（已跟踪文件自上次提交后都未被更改过、也没有任何处于未跟踪状态的新文件）。
这里分支名是默认的`master`，你可以修改`init.defaultbranch`配置项来修改默认分支名。


未跟踪的文件意味着Git之前的快照（提交）中没有这些文件；Git不会自动将之纳入跟踪范围。这样的处理让你不必担心将生成的二进制文件或其他不想被Git跟踪的文件纳入仓库中。

要暂存更新，需要运行`git add`命令，可以用它开始跟踪新文件，或把已跟踪文件放到暂存区，还能用于合并时把冲突文件标记为已解决状态等。
可以将这个命令理解为：`精确地将内容添加到下一次提交中`

使用`git status`命令的输出十分详细，但用语略繁琐。可以使用`git status -s`或`git status --short`命令来查看简短的输出。
```shell
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
```
> 来个示例

- `??`：新添加的未跟踪文件
- `A`：新添加到暂存区中的文件（已修改已暂存）
- `M`：修改过的文件（已修改未暂存）
- `MM`：修改过并放入暂存区的文件（已修改已暂存后，又新增了修改）

## 忽略文件

有些文件无需纳入Git管理，也不希望出现在未跟踪文件列表（通常是自动生成的文件，如日志文件，或编译期创建的临时文件）。可以创建一个名为`.gitignore`的文件，列出要忽略的文件模式。
```shell
$ cat .gitignore
*.[oa]
*~
```

第一行告诉Git忽略所有以`.o`或`.a`结尾的文件
第二行告诉Git忽略所有以波浪符`~`结尾的文件

文件`.gitignore`格式规范如下：
- 所有空行或者以`#`开头的行都会被Git忽略。
- 可以使用标准的`glob模式`匹配（递归应用到整个工作区）
- 匹配模式可以以`/`开头防止递归。
- 匹配模式可以以`/`结尾指定目录。
- 要忽略指定模式以外的文件或目录，可以在模式前加上叹号`!`取反。

所谓的[glob模式](https://en.wikipedia.org/wiki/Glob_(programming))，是一种简化的正则表达式。
- 星号`*`匹配零个或多个任意字符；
- `[abc]`匹配任何一个列在方括号中的字符（这个例子要么匹配一个a，要么匹配一个b，要么匹配一个c）；
- 问号`?`只匹配一个任意字符；
- 范围匹配，如`[0-9]`表示匹配所有0到9的数字；
- 使用两个星号`**`表示匹配任意中间目录，如`a/**/z`可以匹配`a/z`、`a/b/z`或`a/b/c/z`等。

再来看一个例子：
```shell
# 忽略所有的 .a 文件
*.a
# 但跟踪所有的 lib.a，即使你在前面忽略了 .a 文件
!lib.a
# 忽略doc目录下后缀名为md的子文件
doc/*.md
# 忽略doc目录下的所有pdf文件
doc/*.pdf
# 忽略任何路径为/ios/Pods的文件夹
**/ios/Pods/
# 忽略当前目录下的coverage文件
/coverage
# 忽略任何目录下名为.cxx的文件夹
.cxx/
```

> github有一个针对多种语言的十分详细的gitignore文件列表。可[在此](https://github.com/github/gitignore)找到它
> 一般一个项目只需一个`.gitignore`文件，它递归地应用到整个仓库。然而子目录也是可以有自己的`.gitignore`文件的。子目录中的`.gitignore`只作用于它所在的目录中（可以扩展/覆盖父级规则）。

## 查看修改

想知道具体修改了哪些地方，可以使用`git diff`命令。它比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。
若要查看已暂存的将要添加到下次提交里的内容，可以用`git diff --staged`命令。这条命令将比对已暂存文件与最后一次提交的文件差异。

> `git diff`本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。
