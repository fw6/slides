# Git 基础

## 什么是版本控制

版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。

有了它，就能将特定文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。
使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，也照样可以轻松恢复到原先的样子。

版本控制系统分为：
1. 本地版本控制系统：复制整个项目目录来保存不同版本，或许还会改名+备份时间以示区别。好处是简单，缺点是容易犯错。比较流行的一种方式是[RCS](https://www.gnu.org/software/rcs/)，工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化），通过应用所有的补丁，可以重新计算出各个版本的文件内容。
2. 集中化的版本控制系统(CVCS，centralized version control systems)：这类系统，诸如CVS、Subversion以及Perforce等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。缺点是中央服务器的单点故障，如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。如果中央数据库所在的磁盘发生损坏，或者数据库备份没做好，就会导致丢失所有数据。
3. 分布式版本控制系统（DVCS，distributed version control system）：这类系统，诸如Git、Mercurial、Bazaar以及Darcs等，客户端不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。

## Git 是什么

Git和其他版本控制系统最主要差别在于Git对待数据的方式。

其他大部分系统以文件变更列表的方式存储信息，这类系统**将他们存储的信息看作一组基本文件和每个文件随时间逐步累积的差异**。他们通常被称作基于差异（delta-based）或增量（incremental）的版本控制系统。
> 缺个图

Git不按照以上方式对待或保存数据。反之，Git更像是把数据看作是对小型文件系统的一组快照。
在Git中，每当你提交更新或保存项目状态时，**它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引**。
为了高效，如果文件没有修改，Git不会再次保存该文件，只保留一个链接指向之前存储的文件。Git对待数据更像是一个**[快照](https://zh.wikipedia.org/wiki/%E5%BF%AB%E7%85%A7_(%E9%9B%BB%E8%85%A6%E5%84%B2%E5%AD%98))流**。
> 缺个图


Git更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不是一个简单的VCS。

1. 几乎所有操作都是本地执行。如：浏览项目历史、提交更新、查看分支等等。意味着离线情况下几乎可以进行任何操作。
2. Git保证完整性。Git中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。
   > Git用于计算校验和的机制叫做SHA-1散列（hash，哈希）。这是一个由40个十六进制字符（0-9和a-f）组成的字符串，基于Git中文件的内容或目录结构计算出来。实际上，Git数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。
3. Git一般只添加数据。几乎所有操作都是添加数据。你执行的大部分操作，只需向数据库中填入数据，而很少会做任何不可逆的操作，如删除数据。

## Git 的三种状态

Git有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。
- 已修改表示修改了文件，但还没保存到数据库中。
- 已暂存表示对已修改文件的当前版本做了标记，使之包含在下次提交的快照中。
- 已提交表示数据已经安全地保存在本地数据库中。
> 缺个图。展示三种状态之间的关系

- 工作区是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。
- 暂存区是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。Git术语称作‘索引’，不过一般说法还是叫暂存区。
- Git仓库是Git用来保存项目的元数据和对象数据库的地方。这是Git最重要的部分，从其他计算机克隆仓库时，拷贝的就是这里的数据。

如果Git目录中保存着特定版本的文件，就属于*已提交*状态。如果文件已修改并放入了暂存区，就属于*已暂存*状态。如果自上次取出后，作了修改但还没有放到暂存区域，就是*已修改*状态。

## Git配置

Git自带一个git config的工具来帮助设置控制Git外观和行为的配置变量。这些变量存放在三个不同的位置：
1. /etc/gitconfig文件：包含系统上每一个用户及他们仓库的通用配置。如果使用带有--system选项的git config时，它会从此文件读写配置变量。
2. ~/.gitconfig文件：只针对当前用户。可以传递--global选项让Git读写此文件。
3. 当前使用仓库的Git目录中的config文件（就是.git/config）：针对该仓库。

每一个级别覆盖上一级别的配置，所以.git/config里的配置变量会覆盖/etc/gitconfig中的配置变量。

可以使用如下命令查看所有的配置以及它们所在的文件：
```shell
$ git config --list --show-origin
```

初次使用Git时要做的第一件事就是设置你的名字和邮箱地址。每次Git提交时都会引用这两条信息，如下：
```shell
$ git config --global user.name feng.w
$ git config --global user.email feng.w@trip.com
```

如果要检查你的配置，可以使用git config --list命令来列出所有Git当时能找到的配置。
```shell
$ git config --list
credential.helper=osxkeychain
init.defaultbranch=main
user.email=feng.w@trip.com
user.name=feng.w
```

可以查询某个特定配置项的原始值，它会告诉你哪个配置文件最后设置了该值：
```shell
$ git config --show-origin user.name
file:/Users/fengwei/.gitconfig-work     feng.w
```

## 仓库初始化

执行`git init`，将创建一个名为`.git`的子目录，这个子目录含有初始化的Git仓库中所有的必须文件，这些文件是Git仓库的骨干。此时项目中文件还未被跟踪


## 文件状态

检查文件状态：
```shell
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean
```

这说明当前的工作目录相当干净（已跟踪文件自上次提交后都未被更改过、也没有任何处于未跟踪状态的新文件）。
这里分支名是默认的`master`，你可以修改`init.defaultbranch`配置项来修改默认分支名。


未跟踪的文件意味着Git之前的快照（提交）中没有这些文件；Git不会自动将之纳入跟踪范围。这样的处理让你不必担心将生成的二进制文件或其他不想被Git跟踪的文件纳入仓库中。

要暂存更新，需要运行`git add`命令，可以用它开始跟踪新文件，或把已跟踪文件放到暂存区，还能用于合并时把冲突文件标记为已解决状态等。
可以将这个命令理解为：`精确地将内容添加到下一次提交中`

使用`git status`命令的输出十分详细，但用语略繁琐。可以使用`git status -s`或`git status --short`命令来查看简短的输出。
```shell
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
```
> 来个示例

- `??`：新添加的未跟踪文件
- `A`：新添加到暂存区中的文件（已修改已暂存）
- `M`：修改过的文件（已修改未暂存）
- `MM`：修改过并放入暂存区的文件（已修改已暂存后，又新增了修改）

## 忽略文件

有些文件无需纳入Git管理，也不希望出现在未跟踪文件列表（通常是自动生成的文件，如日志文件，或编译期创建的临时文件）。可以创建一个名为`.gitignore`的文件，列出要忽略的文件模式。
```shell
$ cat .gitignore
*.[oa]
*~
```

第一行告诉Git忽略所有以`.o`或`.a`结尾的文件
第二行告诉Git忽略所有以波浪符`~`结尾的文件

文件`.gitignore`格式规范如下：
- 所有空行或者以`#`开头的行都会被Git忽略。
- 可以使用标准的`glob模式`匹配（递归应用到整个工作区）
- 匹配模式可以以`/`开头防止递归。
- 匹配模式可以以`/`结尾指定目录。
- 要忽略指定模式以外的文件或目录，可以在模式前加上叹号`!`取反。

所谓的[glob模式](https://en.wikipedia.org/wiki/Glob_(programming))，是一种简化的正则表达式。
- 星号`*`匹配零个或多个任意字符；
- `[abc]`匹配任何一个列在方括号中的字符（这个例子要么匹配一个a，要么匹配一个b，要么匹配一个c）；
- 问号`?`只匹配一个任意字符；
- 范围匹配，如`[0-9]`表示匹配所有0到9的数字；
- 使用两个星号`**`表示匹配任意中间目录，如`a/**/z`可以匹配`a/z`、`a/b/z`或`a/b/c/z`等。

再来看一个例子：
```shell
# 忽略所有的 .a 文件
*.a
# 但跟踪所有的 lib.a，即使你在前面忽略了 .a 文件
!lib.a
# 忽略doc目录下后缀名为md的子文件
doc/*.md
# 忽略doc目录下的所有pdf文件
doc/*.pdf
# 忽略任何路径为/ios/Pods的文件夹
**/ios/Pods/
# 忽略当前目录下的coverage文件
/coverage
# 忽略任何目录下名为.cxx的文件夹
.cxx/
```

> github有一个针对多种语言的十分详细的gitignore文件列表。可[在此](https://github.com/github/gitignore)找到它
> 一般一个项目只需一个`.gitignore`文件，它递归地应用到整个仓库。然而子目录也是可以有自己的`.gitignore`文件的。子目录中的`.gitignore`只作用于它所在的目录中（可以扩展/覆盖父级规则）。

## 查看修改

想知道具体修改了哪些地方，可以使用`git diff`命令。它比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。
若要查看已暂存的将要添加到下次提交里的内容，可以用`git diff --staged`命令。这条命令将比对已暂存文件与最后一次提交的文件差异。

> `git diff`本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。

暂存区准备就绪之后，就可以提交了。运行提交命令：
```shell
$ git commit
```
会启动文本编辑器来输入提交说明.
> 启动的编辑器是通过SHELL的环境变量EDITOR指定的，一般为vim或emacs

也可以在命令后面加上`-m`参数，将提交说明直接跟在命令后面。

提交时记录的是放在暂存区的快照。任何还未暂存文件仍然保持已修改状态。每次运行提交命令都是对项目进行一次快照。

在提交时，给`git commit`加上-a选项，Git会自动把所有已经**跟踪过**的文件暂存起来一并提交，从而跳过`git add`步骤。

要从Git中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用`git rm`命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。

希望将文件从Git仓库中删除，但仍然希望保留在当前工作目录中，可以使用`--cached`选项：
```shell
$ git rm --cached log/\*.log
```

## 移动文件

Git并不跟踪文件移动操作，只是在内部记录下文件移动的操作。所以，如果要移动文件，只需在Git中把它们重命名即可：
```shell
$ git mv file_from file_to
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
```

其实，运行`git mv`就相当于运行了下面三条命令：
```shell
$ mv README.md README
$ git rm README.md
$ git add README
```

这样分开操作，Git也能知道是一次重命名操作，两者是一样的。

## 查看提交历史

查看提交历史，可以使用`git log`命令。不加任何参数的话，会按提交时间列出所有的更新，最近的更新排在最上面。

`git log`常用的选项是`-p`或`--patch`，它会显示每次提交引入的差异。也可以限制显示的日志数量，如`-2`表示只显示最近的两次更新。
```shell
$ git log -p -2
```
该选项除了显示基本信息之外，还附带了每次提交的变化。当进行代码审查，或者快速浏览某个搭档的提交所带来的变化时，这个参数就非常有用。

使用`git log`可以使用`--stat`查看提交的简略统计信息：
```shell
$ git log --stat
```

`--pretty`选项可以指定使用不同于默认格式的方式展示提交历史。比如，使用`oneline`参数，可以将每个提交放在一行显示，这样每个提交就只占一行了：
```shell
$ git log --pretty=oneline
```
其他还有：
- `short`
- `full`
- `fuller`
暂时的信息基本一致，但是详尽程度不一

`--pretty`选项还可以定制输出的格式。`format`参数可以指定输出的格式，然后指定相应的占位符。比如，`%h`表示提交对象（commit）的简短哈希值，`%an`表示作者名，`%ar`表示作者修订日期，`%s`表示提交说明。
```shell
$ git log --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset'
```

下表列出了常用的选项：
| 选项 | 说明                                        |
| ---- | ------------------------------------------- |
| %H   | 提交对象（commit）的完整哈希字串            |
| %h   | 提交对象的简短哈希字串                      |
| %T   | 树对象（tree）的完整哈希字串                |
| %t   | 树对象的简短哈希字串                        |
| %P   | 父对象（parent）的完整哈希字串              |
| %p   | 父对象的简短哈希字串                        |
| %an  | 作者（author）的名字                        |
| %ae  | 作者的电子邮件地址                          |
| %ad  | 作者修订日期（可以用 --date= 选项定制格式） |
| %ar  | 作者修订日期，按多久以前的方式显示          |
| %cn  | 提交者(committer)的名字                     |
| %ce  | 提交者的电子邮件地址                        |
| %cd  | 提交日期                                    |
| %cr  | 提交日期，按多久以前的方式显示              |
| %s   | 提交说明                                    |

不知你们有没有发现有作者还有个提交者。其实作者指的是实际做出修改的人，提交者指的是最后将此工作成果提交的人。例如，当你为某个项目发布补丁，某个核心成员将补丁并入了项目，那么这个核心成员就是提交者，而你则是作者。

当`oneline`和`format`选项与`--graph`选项配合使用时，可以看到分支合并图：
```shell
$ git log --pretty=format:'%h %s' --graph
*   bbbce290 (HEAD -> develop, origin/develop) Merge branch 'content/dev_s141_20231221' into develop
|\
| * 6a62441b (origin/content/dev_s141_20231221) fix: creation center change show label logic
* |   a36f6c07 Merge remote-tracking branch 'origin/kol/dev_s141_20231221' into develop
```

`--graph`选项会在左侧用ASCII字符绘制一幅表示分支合并历史的图形。

下表列出了`git log`常用的选项：
| 选项            | 说明                                                                                                  |
| --------------- | ----------------------------------------------------------------------------------------------------- |
| -p              | 按补丁格式显示每个更新之间的差异。                                                                    |
| --stat          | 显示每次更新的文件修改统计信息。                                                                      |
| --shortstat     | 只显示 -stat 中最后的行数修改添加移除统计。                                                           |
| --name-only     | 仅在提交信息后显示已修改的文件清单。                                                                  |
| --name-status   | 显示新增、修改、删除的文件清单。                                                                      |
| --abbrev-commit | 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。                                                     |
| --relative-date | 使用较短的相对时间显示（比如，“2 weeks ago”）。                                                       |
| --graph         | 显示 ASCII 图形表示的分支合并历史。                                                                   |
| --pretty        | 使用其他格式显示历史提交信息。可用的选项包括 oneline、short、full、fuller 和 format（后跟指定格式）。 |
| --oneline       | `--pretty=oneline --abbrev-commit` 的简写。                                                           |


如果觉得输出信息太多，可以使用`-n`选项限制显示的日志数量。不过在实际展示log时，Git默认会将所有输出传送到分页程序中，所以你一次只会看到一页的内容。
> 可以配置默认分页程序，如`git config --global core.pager 'delta'`

类似`--since`和`--until`这种按照时间做限制的选项很有用。
```shell
$ git log --since=2.weeks
```

这个命令可以是确定日期，也可以是相对日期。还可以过滤指定条件的提交。`--author`选项显示指定作者的提交，`--grep`选项搜索提交说明中的关键字。
另一个很有用的过滤器是`-S`选项，只显示添加或移除了某个关键字的提交。
```shell
$ git log -S function_name
```

下表列出了`git log`常用的过滤选项：
| 选项              | 说明                               |
| ----------------- | ---------------------------------- |
| -(n)              | 仅显示最近的 n 条提交              |
| --since, --after  | 仅显示指定时间之后的提交。         |
| --until, --before | 仅显示指定时间之前的提交。         |
| --author          | 仅显示指定作者相关的提交。         |
| --committer       | 仅显示指定提交者相关的提交。       |
| --grep            | 仅显示含指定关键字的提交           |
| -S                | 仅显示添加或移除了某个关键字的提交 |

下方命令只会显示最近两周内，feng.w提交的，包含`fix`关键字的提交(不包含合并提交)：
```shell
$ git log --since=2.weeks --author=feng.w --grep=fix --no-merges
```

## 撤销操作
